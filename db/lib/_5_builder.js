// Generated by CoffeeScript 1.6.3
(function() {
  var Builder, root;
  root = this;
  Builder = (function() {
    function Builder(schema_name, table_name, search_path, query) {
      var _base;
      this.schema_name = schema_name;
      this.table_name = table_name;
      this.search_path = search_path;
      this.query = query;
      if ((_base = this.query).select == null) {
        _base.select = "*";
      }
      this.params = [];
      this.i = 0;
    }

    Builder.prototype.qm = function() {
      return "$" + (this.i += 1);
    };

    Builder.prototype.make_distinct = function() {
      return _.map(this.query.distinct.split(","), function(f) {
        return "data->>'" + f + "' AS " + f;
      }).join(", ");
    };

    Builder.prototype.make_select = function() {
      if (this.query.select === "*") {
        return "data";
      } else if (_.isArray(this.query.select)) {
        this.params.push(this.query.select.join(","));
        return "__select(data, " + (this.qm()) + ") as data";
      } else {
        return this.query.select;
      }
    };

    Builder.prototype.make_where = function(q, join_by) {
      var comparisons, k, sql, subquery, symbol, value, _i, _len;
      if (join_by == null) {
        join_by = 'AND';
      }
      sql = [];
      for (k in q) {
        subquery = q[k];
        switch (k) {
          case 'and':
          case 'AND':
          case '&':
          case '&&':
            sql.push("(" + (this.make_where(subquery, 'AND')) + ")");
            break;
          case 'or':
          case 'OR':
          case '|':
          case '||':
            sql.push("(" + (this.make_where(subquery, 'OR')) + ")");
            break;
          case 'not':
          case 'NOT':
          case '!':
            sql.push("NOT (" + (this.make_where(subquery, 'AND')) + ")");
            break;
          case 'raw':
            sql.push(subquery);
            break;
          default:
            if (_.isArray(subquery)) {
              this.params.push(k);
              this.params.push(subquery[1]);
              sql.push("" + (this.plv8_key(subquery[1])) + " " + subquery[0] + " " + (this.plv8_qm(subquery[1])));
            } else if (_.isObject(subquery)) {
              comparisons = [];
              for (value = _i = 0, _len = subquery.length; _i < _len; value = ++_i) {
                symbol = subquery[value];
                comparisons.push("" + symbol + " " + (this.plv8_qm(value)));
                this.params.push(k);
                this.params.push(value);
              }
              sql.push(_.map(comparisons, function(comparison) {
                return "" + (this.plv8_key(value)) + " " + comparison;
              }).join(" AND "));
            } else {
              this.params.push(k);
              this.params.push(subquery);
              sql.push("" + (this.plv8_key(subquery)) + " = " + (this.plv8_qm(subquery)));
            }
        }
      }
      return sql.join("\n" + join_by + " ");
    };

    Builder.prototype.make_order_by = function() {
      var k, ord, str, v, _i, _len;
      str = [];
      ord = this.query.order_by;
      if (_.isArray(ord)) {
        this.params.push(ord[0]);
        str.push("" + (this.plv8_key(ord[1])) + " " + (ord[1].toUpperCase()));
      } else if (_.isObject(ord)) {
        for (v = _i = 0, _len = ord.length; _i < _len; v = ++_i) {
          k = ord[v];
          this.params.push(v);
          str.push("" + (this.plv8_key(k)) + " " + (k.toUpperCase()));
        }
      } else if (ord != null) {
        str.push(ord);
      }
      return str.join(",");
    };

    Builder.prototype.make_group_by = function() {
      var k, ord, str, v, _i, _len;
      str = [];
      ord = this.query.group_by;
      if (this.query.distinct) {
        str.push(_.map(this.query.distinct.split(","), function(f) {
          return "data->>'" + f + "'";
        }));
      }
      if (_.isArray(ord)) {
        this.params.push(ord[0]);
        str.push("" + (this.plv8_key(ord[1])) + " " + (ord[1].toUpperCase()));
      } else if (_.isObject(ord)) {
        for (v = _i = 0, _len = ord.length; _i < _len; v = ++_i) {
          k = ord[v];
          this.params.push(v);
          str.push("" + (this.plv8_key(k)) + " " + (k.toUpperCase()));
        }
      } else if (ord != null) {
        str.push(ord);
      }
      return _.flatten(str).join(",");
    };

    Builder.prototype.make_limit = function() {
      this.params.push(this.query.limit);
      return this.qm();
    };

    Builder.prototype.make_offset = function() {
      this.params.push(this.query.offset);
      return this.qm();
    };

    Builder.prototype.build_select = function() {
      var sql;
      sql = [];
      sql.push("SET search_path TO " + this.search_path + ";");
      sql.push("SELECT");
      if (this.query.distinct != null) {
        sql.push("DISTINCT " + (this.make_distinct()) + ",");
      }
      sql.push("" + (this.make_select()) + " FROM " + this.schema_name + "." + this.table_name);
      if (!_.isEmpty(this.query.where)) {
        sql.push("WHERE " + (this.make_where(this.query.where)));
      }
      if ((this.query.group_by != null) || (this.query.distinct != null)) {
        sql.push("GROUP BY " + (this.make_group_by()));
      }
      if (this.query.order_by != null) {
        sql.push("ORDER BY " + (this.make_order_by()));
      }
      if (this.query.limit != null) {
        sql.push("LIMIT " + (this.make_limit()));
      }
      if (this.query.offset != null) {
        sql.push("OFFSET " + (this.make_offset()));
      }
      return [sql.join("\n"), this.params];
    };

    Builder.prototype.build_delete = function() {
      var sql;
      sql = [];
      sql.push("SET search_path TO " + this.search_path + ";");
      sql.push("DELETE FROM " + this.schema_name + "." + this.table_name);
      if (!_.isEmpty(this.query.where)) {
        sql.push("WHERE " + (this.make_where(this.query.where)));
      }
      sql.push("RETURNING data::json;");
      return [sql.join("\n"), this.params];
    };

    Builder.prototype.build_update = function(data, merge) {
      var sql;
      if (merge == null) {
        merge = true;
      }
      this.params.push(data);
      this.params.push(merge);
      sql = [];
      sql.push("SET search_path TO " + this.search_path + ";");
      sql.push("UPDATE " + this.schema_name + "." + this.table_name + " SET data = __patch(data," + (this.qm()) + "," + (this.qm()) + ")");
      if (!_.isEmpty(this.query.where)) {
        sql.push("WHERE " + (this.make_where(this.query.where)));
      }
      sql.push("RETURNING data::json;");
      return [sql.join("\n"), this.params];
    };

    Builder.prototype.build_insert = function(data, merge) {
      var sql;
      if (merge == null) {
        merge = true;
      }
      this.params.push(data);
      this.params.push(merge);
      sql = [];
      sql.push("SET search_path TO " + this.search_path + ";");
      sql.push("INSERT INTO " + this.schema_name + "." + this.table_name + " (data) VALUES (__patch(__defaults()," + (this.qm()) + "," + (this.qm()) + "))");
      sql.push("RETURNING data::json;");
      return [sql.join("\n"), this.params];
    };

    Builder.prototype.plv8_key = function(value) {
      return "" + (this.typecast(value, true)) + "(data, " + (this.qm()) + "::text)";
    };

    Builder.prototype.plv8_qm = function(value) {
      return "" + (this.qm()) + "::" + (this.typecast(value));
    };

    Builder.prototype.typecast = function(value, is_func) {
      var type;
      if (is_func == null) {
        is_func = false;
      }
      type = is_func ? "__" : "";
      if (_.isBoolean(value)) {
        type += "bool";
      } else if (_.isDate(value)) {
        type += "timestamp";
      } else if (_.isNumber(value)) {
        type += "integer";
      } else if (_.isObject(value)) {
        type += (is_func ? "text" : "json");
      } else if (_.isArray(value)) {
        type += (is_func ? "text" : "array");
      } else {
        type += (is_func ? "string" : "text");
      }
      return type;
    };

    return Builder;

  })();
  return root.actn.Builder = Builder;
}).call(this);
